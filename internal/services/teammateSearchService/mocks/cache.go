// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/DmitriySama/teammate_search/internal/models"
	mock "github.com/stretchr/testify/mock"
)

// MockUsersCache is an autogenerated mock type for the UsersCache type
type MockUsersCache struct {
	mock.Mock
}

type MockUsersCache_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUsersCache) EXPECT() *MockUsersCache_Expecter {
	return &MockUsersCache_Expecter{mock: &_m.Mock}
}

// GetApps provides a mock function with given fields: ctx
func (_m *MockUsersCache) GetApps(ctx context.Context) ([]models.Apps, bool) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetApps")
	}

	var r0 []models.Apps
	var r1 bool
	if rf, ok := ret.Get(0).(func(context.Context) ([]models.Apps, bool)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []models.Apps); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Apps)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) bool); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// MockUsersCache_GetApps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetApps'
type MockUsersCache_GetApps_Call struct {
	*mock.Call
}

// GetApps is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUsersCache_Expecter) GetApps(ctx interface{}) *MockUsersCache_GetApps_Call {
	return &MockUsersCache_GetApps_Call{Call: _e.mock.On("GetApps", ctx)}
}

func (_c *MockUsersCache_GetApps_Call) Run(run func(ctx context.Context)) *MockUsersCache_GetApps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUsersCache_GetApps_Call) Return(_a0 []models.Apps, _a1 bool) *MockUsersCache_GetApps_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUsersCache_GetApps_Call) RunAndReturn(run func(context.Context) ([]models.Apps, bool)) *MockUsersCache_GetApps_Call {
	_c.Call.Return(run)
	return _c
}

// GetGames provides a mock function with given fields: ctx
func (_m *MockUsersCache) GetGames(ctx context.Context) ([]models.Games, bool) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetGames")
	}

	var r0 []models.Games
	var r1 bool
	if rf, ok := ret.Get(0).(func(context.Context) ([]models.Games, bool)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []models.Games); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Games)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) bool); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// MockUsersCache_GetGames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGames'
type MockUsersCache_GetGames_Call struct {
	*mock.Call
}

// GetGames is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUsersCache_Expecter) GetGames(ctx interface{}) *MockUsersCache_GetGames_Call {
	return &MockUsersCache_GetGames_Call{Call: _e.mock.On("GetGames", ctx)}
}

func (_c *MockUsersCache_GetGames_Call) Run(run func(ctx context.Context)) *MockUsersCache_GetGames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUsersCache_GetGames_Call) Return(_a0 []models.Games, _a1 bool) *MockUsersCache_GetGames_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUsersCache_GetGames_Call) RunAndReturn(run func(context.Context) ([]models.Games, bool)) *MockUsersCache_GetGames_Call {
	_c.Call.Return(run)
	return _c
}

// GetGenres provides a mock function with given fields: ctx
func (_m *MockUsersCache) GetGenres(ctx context.Context) ([]models.Genres, bool) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetGenres")
	}

	var r0 []models.Genres
	var r1 bool
	if rf, ok := ret.Get(0).(func(context.Context) ([]models.Genres, bool)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []models.Genres); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Genres)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) bool); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// MockUsersCache_GetGenres_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGenres'
type MockUsersCache_GetGenres_Call struct {
	*mock.Call
}

// GetGenres is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUsersCache_Expecter) GetGenres(ctx interface{}) *MockUsersCache_GetGenres_Call {
	return &MockUsersCache_GetGenres_Call{Call: _e.mock.On("GetGenres", ctx)}
}

func (_c *MockUsersCache_GetGenres_Call) Run(run func(ctx context.Context)) *MockUsersCache_GetGenres_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUsersCache_GetGenres_Call) Return(_a0 []models.Genres, _a1 bool) *MockUsersCache_GetGenres_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUsersCache_GetGenres_Call) RunAndReturn(run func(context.Context) ([]models.Genres, bool)) *MockUsersCache_GetGenres_Call {
	_c.Call.Return(run)
	return _c
}

// GetLanguages provides a mock function with given fields: ctx
func (_m *MockUsersCache) GetLanguages(ctx context.Context) ([]models.Language, bool) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLanguages")
	}

	var r0 []models.Language
	var r1 bool
	if rf, ok := ret.Get(0).(func(context.Context) ([]models.Language, bool)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []models.Language); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Language)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) bool); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// MockUsersCache_GetLanguages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLanguages'
type MockUsersCache_GetLanguages_Call struct {
	*mock.Call
}

// GetLanguages is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUsersCache_Expecter) GetLanguages(ctx interface{}) *MockUsersCache_GetLanguages_Call {
	return &MockUsersCache_GetLanguages_Call{Call: _e.mock.On("GetLanguages", ctx)}
}

func (_c *MockUsersCache_GetLanguages_Call) Run(run func(ctx context.Context)) *MockUsersCache_GetLanguages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockUsersCache_GetLanguages_Call) Return(_a0 []models.Language, _a1 bool) *MockUsersCache_GetLanguages_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockUsersCache_GetLanguages_Call) RunAndReturn(run func(context.Context) ([]models.Language, bool)) *MockUsersCache_GetLanguages_Call {
	_c.Call.Return(run)
	return _c
}

// Key provides a mock function with given fields: prefix, id
func (_m *MockUsersCache) Key(prefix string, id string) string {
	ret := _m.Called(prefix, id)

	if len(ret) == 0 {
		panic("no return value specified for Key")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(prefix, id)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockUsersCache_Key_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Key'
type MockUsersCache_Key_Call struct {
	*mock.Call
}

// Key is a helper method to define mock.On call
//   - prefix string
//   - id string
func (_e *MockUsersCache_Expecter) Key(prefix interface{}, id interface{}) *MockUsersCache_Key_Call {
	return &MockUsersCache_Key_Call{Call: _e.mock.On("Key", prefix, id)}
}

func (_c *MockUsersCache_Key_Call) Run(run func(prefix string, id string)) *MockUsersCache_Key_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockUsersCache_Key_Call) Return(_a0 string) *MockUsersCache_Key_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUsersCache_Key_Call) RunAndReturn(run func(string, string) string) *MockUsersCache_Key_Call {
	_c.Call.Return(run)
	return _c
}

// SetApps provides a mock function with given fields: ctx, apps
func (_m *MockUsersCache) SetApps(ctx context.Context, apps []models.Apps) error {
	ret := _m.Called(ctx, apps)

	if len(ret) == 0 {
		panic("no return value specified for SetApps")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []models.Apps) error); ok {
		r0 = rf(ctx, apps)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUsersCache_SetApps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetApps'
type MockUsersCache_SetApps_Call struct {
	*mock.Call
}

// SetApps is a helper method to define mock.On call
//   - ctx context.Context
//   - apps []models.Apps
func (_e *MockUsersCache_Expecter) SetApps(ctx interface{}, apps interface{}) *MockUsersCache_SetApps_Call {
	return &MockUsersCache_SetApps_Call{Call: _e.mock.On("SetApps", ctx, apps)}
}

func (_c *MockUsersCache_SetApps_Call) Run(run func(ctx context.Context, apps []models.Apps)) *MockUsersCache_SetApps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]models.Apps))
	})
	return _c
}

func (_c *MockUsersCache_SetApps_Call) Return(_a0 error) *MockUsersCache_SetApps_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUsersCache_SetApps_Call) RunAndReturn(run func(context.Context, []models.Apps) error) *MockUsersCache_SetApps_Call {
	_c.Call.Return(run)
	return _c
}

// SetGames provides a mock function with given fields: ctx, games
func (_m *MockUsersCache) SetGames(ctx context.Context, games []models.Games) error {
	ret := _m.Called(ctx, games)

	if len(ret) == 0 {
		panic("no return value specified for SetGames")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []models.Games) error); ok {
		r0 = rf(ctx, games)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUsersCache_SetGames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetGames'
type MockUsersCache_SetGames_Call struct {
	*mock.Call
}

// SetGames is a helper method to define mock.On call
//   - ctx context.Context
//   - games []models.Games
func (_e *MockUsersCache_Expecter) SetGames(ctx interface{}, games interface{}) *MockUsersCache_SetGames_Call {
	return &MockUsersCache_SetGames_Call{Call: _e.mock.On("SetGames", ctx, games)}
}

func (_c *MockUsersCache_SetGames_Call) Run(run func(ctx context.Context, games []models.Games)) *MockUsersCache_SetGames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]models.Games))
	})
	return _c
}

func (_c *MockUsersCache_SetGames_Call) Return(_a0 error) *MockUsersCache_SetGames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUsersCache_SetGames_Call) RunAndReturn(run func(context.Context, []models.Games) error) *MockUsersCache_SetGames_Call {
	_c.Call.Return(run)
	return _c
}

// SetGenres provides a mock function with given fields: ctx, genres
func (_m *MockUsersCache) SetGenres(ctx context.Context, genres []models.Genres) error {
	ret := _m.Called(ctx, genres)

	if len(ret) == 0 {
		panic("no return value specified for SetGenres")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []models.Genres) error); ok {
		r0 = rf(ctx, genres)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUsersCache_SetGenres_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetGenres'
type MockUsersCache_SetGenres_Call struct {
	*mock.Call
}

// SetGenres is a helper method to define mock.On call
//   - ctx context.Context
//   - genres []models.Genres
func (_e *MockUsersCache_Expecter) SetGenres(ctx interface{}, genres interface{}) *MockUsersCache_SetGenres_Call {
	return &MockUsersCache_SetGenres_Call{Call: _e.mock.On("SetGenres", ctx, genres)}
}

func (_c *MockUsersCache_SetGenres_Call) Run(run func(ctx context.Context, genres []models.Genres)) *MockUsersCache_SetGenres_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]models.Genres))
	})
	return _c
}

func (_c *MockUsersCache_SetGenres_Call) Return(_a0 error) *MockUsersCache_SetGenres_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUsersCache_SetGenres_Call) RunAndReturn(run func(context.Context, []models.Genres) error) *MockUsersCache_SetGenres_Call {
	_c.Call.Return(run)
	return _c
}

// SetLanguages provides a mock function with given fields: ctx, languages
func (_m *MockUsersCache) SetLanguages(ctx context.Context, languages []models.Language) error {
	ret := _m.Called(ctx, languages)

	if len(ret) == 0 {
		panic("no return value specified for SetLanguages")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []models.Language) error); ok {
		r0 = rf(ctx, languages)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockUsersCache_SetLanguages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLanguages'
type MockUsersCache_SetLanguages_Call struct {
	*mock.Call
}

// SetLanguages is a helper method to define mock.On call
//   - ctx context.Context
//   - languages []models.Language
func (_e *MockUsersCache_Expecter) SetLanguages(ctx interface{}, languages interface{}) *MockUsersCache_SetLanguages_Call {
	return &MockUsersCache_SetLanguages_Call{Call: _e.mock.On("SetLanguages", ctx, languages)}
}

func (_c *MockUsersCache_SetLanguages_Call) Run(run func(ctx context.Context, languages []models.Language)) *MockUsersCache_SetLanguages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]models.Language))
	})
	return _c
}

func (_c *MockUsersCache_SetLanguages_Call) Return(_a0 error) *MockUsersCache_SetLanguages_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockUsersCache_SetLanguages_Call) RunAndReturn(run func(context.Context, []models.Language) error) *MockUsersCache_SetLanguages_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUsersCache creates a new instance of MockUsersCache. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUsersCache(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUsersCache {
	mock := &MockUsersCache{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
